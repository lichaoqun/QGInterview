##为什么说OC是动态性的
OC在编译的时候,并不能确定具体是哪个对象执行哪个方法, 而静态语言在编译时候, 具体哪个对象执行哪个方法就已经确定了.
runtime是将数据类型的确定由编译时推迟到了运行时。
##category
在分类中添加属性, 编译成cpp文件, 在分类中只会有_prop_list_t, 没有_method_list_t, _ivar_list_t;
在原类中添加属性, 编译成cpp文件, 在原类中会有 _ivar_list_t, _method_list_t, _prop_list_t
加载流程 : dyld 加载 libobjc, 调用 
->_objc_init -> _dyld_objc_notify_register(&map_images, load_images, unmap_image);
                                            丨            丨
                                            丨             -> call_load_methods() -> while循环调用类的call_class_loads方法, 之后调用分类的laod方法. 他们都是通过函数式指针直接调用的, 而不是用objc_msgSend()调用
                                            丨
                                             -> _read_images -> addUnattachedCategoryForClass() -> remethodizeClass() -> attachCategories -> attachLists(将函数 添加到class_rw_t中);
    do {
        // 1. Repeatedly call class +loads until there aren't any more
        while (loadable_classes_used > 0) {
            call_class_loads();
        }

        // 2. Call category +loads ONCE
        more_categories = call_category_loads();

        // 3. Run more +loads if there are classes OR more untried categories
    } while (loadable_classes_used > 0  ||  more_categories);
    
     
                                                                
##runtime应用
动态添加属性, 用于自释放KVO
自动归档(对于基本数据类型, 需要封装成OC数据类型)
json转model(对于基本数据类型, 需要特殊处理)
动态添加方法(消息决议阶段)
## 离屏渲染
正常情况下,我们在屏幕上显示的内容都是GPU读取帧缓冲中渲染好的数据,然后显示在屏幕上,但是有些时候,我们无法把渲染好的数据直接写入到framebuffer中,而是先缓存在另一块区域,之后在写入到framebuffer中, 这个过程我们称之为离屏渲染. 也就是GPU需要在当前的屏幕缓冲区以外在开辟一块新的缓冲区进行操作.
我们知道coreAnimation的RenderServer模块是负责渲染的, 对于每一层layer, renderServer都会遵循画家算法(由远及进的绘制), 然后按序输入到framebuffer中, 然后再依次绘制到屏幕中, 当绘制完一层, 就会将该层从缓冲区中移除, 但是在某些场景下, 画家算法虽然是逐层输出, 但是无法在某一层渲染完成后在回头修改/擦除某一部分, 因为之前的layer像素已经被永久的覆盖了, 这就意味着每一层的layer要么通过单次遍历就能够完成渲染, 要么只能另外开辟一块空间作为临时中转区来完成复杂的修改/裁剪工作.
##开发中做过哪些优化
启动时间的优化:
main之前:
    减少在load方法内实现函数.
    二进制重排:
        项目中的代码的执行顺序做了简单的二进制重排.
        知道原理后开始将方法定义按顺序写.
main之后: 
    减少使用xib
    将首页的页面的计算放在其他线程中去做
    避免首页使用大量的图片.
    做好网络请求的接口优化(DNS策略)
    
编译时间优化: 
    删除没用的方法和类
    二进制化组件
包体积优化:
        减少使用xib
        大图压缩
        删除没用资源
        删除重复文件.
        图片资源放入.xcassets
        Framework 瘦身
卡顿优化:
    提前计算cell的高度并且缓存cell高度.
    最好直接使用frame, 而不用 Autolayout
    控制线程的最大并发数量
    cellForRowAtIndexPath:只负责创建cell. 在willDisplayCell: forRowAtIndexPath:中绑定数据.
    减少视图层级.
    在子线程预解码image()
        使用 CGBitmapContextCreate 函数创建一个位图上下文；
        使用 CGContextDrawImage 函数将原始位图绘制到上下文中；
        使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。
    懒加载, 合理处理view的加载时机.
    减少使用透明 view
    使用贝塞尔曲线绘制圆角.
    imageView的大小和image相同

##Git命令
rebase : 将当前分支的提交取消并保存为补丁, 然后将当前分支的版本更新到最新的目标分支, 然后保存将保存的补丁应用到当前分支上. 并且解决冲突后不会产生新的commit
merge : 将目标分支的代码合并到当前分支上, 解决冲突会产生新的commit
cherry-pick : 选择一次提交合并到当前的分支上.
git reset [commit] : 回退到某个版本并保存未追踪的改动  --hard : 放弃未提交的改动,将本地仓库全部的操作退回到指定的提交.
git revert [commit] : 创建一个新的commit 来覆盖指定的commit, 就是相当于一次提交, 提交的内容是撤销那次commit的提交.
##事件传递和响应的过程
事件产生后, 系统会将事件加入到一个由UIApplication管理的事件队列中.
事件的传递 : 事件如何从父控件传递到子控件并寻找到最合适的view
事件的响应 : 找到最合适的view后事件的处理（touches方法的重写） 找到合适的view处理事件后, 判断当前的view是否处理touch事件,如果不处理就找父视图, 如果过程中一直都没有view处理这个时间, 这个时间就会被抛弃.
依次三个按钮 a b c,b实现pointinside并返回YES, 然后依次点击三个按钮, 分别打印是 b b c 按钮响应事件.
##kVO中的崩溃
移除了未注册的观察者，导致崩溃。
重复移除多次，移除次数多于添加次数，导致崩溃。
重复添加多次，虽然不会崩溃，但是发生改变时，也同时会被观察多次。
被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃（iOS 10 及之前会崩溃）。
添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context: 方法，导致崩溃。
添加或者移除时 keypath == nil，导致崩溃。
##kVO的底层实现原理
新建一个类 KVONotifying_Person, 继承自被监听的类, 将被监听类的isa指针指向KVONotifying_Person, 当removeob 然后重写属性的setter方法, 方法内部调用先调用willChangeValueForKey: 然后调用 super setter, 然后调用 didChangeValueForKey. 当执行 被监听removeObserver:的时候, 会将isa指针变回来.

## KVO自释放的实现
新建类别NSObject(KVO), 添加kvo_addObserver方法, 新建类ObserverHelp继承自NSObject(声明targe, observer, keypath, factor属性) 在kvo_addObserver中实现
'''
 [self addObserver:observer forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:nil];
 SJObserverHelper *helper = [SJObserverHelper new];
 SJObserverHelper *sub = [SJObserverHelper new];
 sub.target = helper.target = self;
 sub.observer = helper.observer = observer;
 sub.keyPath = helper.keyPath = keyPath;
 helper.factor = sub;
 sub.factor = helper;
 const char *helpeKey = [NSString stringWithFormat:@"%zd", [observer hash]].UTF8String;
 objc_setAssociatedObject(self, helpeKey, helper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 objc_setAssociatedObject(observer, helpeKey, sub, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 '''
##KVC原理
set访问流程: 
setName->_setName->setIsName->accessInstanceVarivablesDirectly()->_name->_isName->name->isName;
get 访问流程:
getName->name->countOfName->objectIndNameAtIndex->accessInstanceVarivablesDirectly()->_name->_isName->name->isName;
在未找到访问器或实例变量时，调用 setValue:forUndefinedKey:。默认情况下，这会引发异常
##主动调用kVO
手动调用 willChangeValueForKey: 和 didChangeValueForKey:
##两个分类都方法交换viewWillAppear
未调用原类的方法:
编译 : vc bvc avc. 结果:avc
调用原类的方法:
编译 : vc bvc avc. 结果:vc bvc avc

##方法调用流程
先找到对象的isa指针指向的class, 在后在class的缓存方法列表中查找方法, 如果没找到,就到当前类的方法列表中查找,如果没有查找到,就去父类的方法缓存中查找方法, 如果没有找到就去父类的方法列表中查找,之后然后一直重复这一过程, 如果找到根类(类的父类是空)也没有找到方法的实现, 就走消息转发的流程.
##消息转发流程
1.  +(BOOL)resolveInstanceMethod:(SEL)sel
    +(BOOL)resolveClassMethod:(SEL)sel
2.  -(id)forwardingTargetForSelector:(SEL)aSelector
3.  -(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
    -(void)forwardInvocation:(NSInvocation *)anInvocation

##为什么string用copy修饰
对于string copy 和 strong是一样的, 但是对于 muableString, copy和strong是不一样的. 修改muableString, copy的修饰的字符串指针不会变, 而strong修饰的指针会变.
##ISA中存储的内容
    has_assoc: 是否有关联对象.
    weakly_referenced:是否被指向或者曾经被一个弱引用的变量指向.
    extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到has_sidetable_rc. 
    has_sidetable_rc:当对象引用技术大于 10 时，则需要SideTable中的refcnts存储引用数
##weak原理  https://www.jianshu.com/p/ed43b17c8a72
struct SideTable {
        RefcountMap refcnts;
        weak_table_t weak_table;
}
 struct weak_table_t {
       weak_entry_t *weak_entries;
}
    
struct weak_entry_t {
    DisguisedPtr<objc_object> referent;
    union {
        struct {
            weak_referrer_t *referrers;
        };
        struct {
            weak_referrer_t  inline_referrers[4];
        };
    }
}
runtime维护了一个weak表, weak表的本质就是一个hash表, key是所指向对象的地址, value是weak修饰的指针的地址数组.
*location 表示弱引用的指针地址, newObj表示指向的对象的地址.
objc_initWeak -> storeWeak -> weak_register_no_lock
1. 通过SideTables *newTable = &SideTables()[newObj]; 将newObj通过一个哈希函数将地址转换成0-StripeCount的一个索引值. 从8个sideTable根据newObj取出sideTable; 之后进入 newObj = weak_register_no_lock(&newTable->weak_table, (id)newObj, location, crashIfDeallocating ? CrashIfDeallocating : ReturnNilIfDeallocating);
2. 通过传入的newObj,在newTable的weak_table的weak_entries中查找 weak_entry_t 
3. 将弱引用指针添加到 weak_entry_t的referrers中.
##weak如何被值为nil
遍历referrers/inline_referrers[4], 将里边的每个指针的指向值为nil, 然后从weak_entries中移除这个weak_entry_t;
## NSCoding协议的方法有哪些
- (void)encodeWithCoder:(NSCoder *)coder; 使用[encodeObject:self.name forKey:@"name"]做归档.
- (nullable instancetype)initWithCoder:(NSCoder *)coder;使用self.name=[coder decodeObjectForKey:@"name"]做解档; 

## NSCopy协议的方法有哪些
##iOS 模型数组深拷贝
使用initWithArray:copyItems:可以实现元素的深拷贝,但是模型数组内元素中模型必须要实现copying协议,模型内如果有嵌套模型，也需要实现copying协议，否则执行对对象拷贝操作会出现崩溃
##扩展和分类的去区别
扩展中声明的属性和方法是编译后和类中的在一起,作为类中方法和成员变量的一部分.
类别中的方法是在程序运行时候加入的.

##pod 命令
pod init : 在当前目录下生成一个 podfile文件
podfile.lock文件内记录了每个pod当前已经安装的版本, 并锁定这些版本.
pod install : 命令会解析尚未列在podfile.lock文件中的pod, 并下载安装这些pod, 然后再podfile.lock文件中写入这些pod;如果某些库已经是列在.lock文件中了,只是改了版本号, pod install就不会尝试更新这些pod的版本.
pod update : 会把podfile中的所有pod更新到最新的版本, 并在podfile.lock中写入新的版本号

## UIView和CALayer的区别 
UIView:
可以响应事件
继承自UIResponder
CALayer: 
无法响应事件
继承自NSObject
绘制这块主要是Layer在负责
对于setFrame setBounds方法, 实际上是调用了layer的setFrame和setbounds;
使用 anchorPoint(0,0), anchorPoint(1,1)分别表示左上角、右下角。
##AssociationsManager原理
1. 初始化AssociationsManager对象
2. 获取AssociationsManager中的静态变量AssociationsHashMap
3. 用DISGUISE函数获取对象地址的反码disguised_object
4. 将对象地址的反码作为key，在AssociationsHashMap哈希表中查找key为disguised_object的ObjectAssociationMap类型的对象
_object_remove_assocations5.如果在第4步中找到ObjectAssociationMap，则继续根据我们传入的关联key继续在ObjectAssociationMap表中查找对应的ObjcAssociation对象，如果找到了，取出其中的value
6.如果在第5步中没找到ObjcAssociation，则该key不存在关联的值
7. 如果在第4步中没有找到ObjectAssociationMap ，则该对象没有设置过关联属性
8. 根据关联策略决定是否对查询到的value进行retain操作或则autorelease
AssociationsManager可重复创建，但是AssociationsHashMap是AssociationsManager内的静态变量，全局只有一个，负责管理所有对象的关联表。通过对象地址的反码取出该对象的属性关联表ObjectAssociationMap。然后再通过关联key从对象关联表中获取对应的ObjectAssociation，ObjectAssociation内存储的就是真正需要的存储的value值和内存关联策略policy了。
关联对象并不存储在被关联对象object本身内存中，而是存储在全局的一个AssociationsHashMap中。设置关联对象的value为nil，就相当于移除关联对象。
##isKindOfClass和 isMemberOfClass方法区别
    BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];           1 
    BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];         0
    BOOL re3 = [(id)[XJPerson class] isKindOfClass:[XJPerson class]];           0
    BOOL re4 = [(id)[XJPerson class] isMemberOfClass:[XJPerson class]];         0
    
    BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];           1
    BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];         1
    BOOL re7 = [(id)[XJPerson alloc] isKindOfClass:[XJPerson class]];           1
    BOOL re8 = [(id)[XJPerson alloc] isMemberOfClass:[XJPerson class]];         1

+ (BOOL)isMemberOfClass:(Class)cls {
    return self->ISA() == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = self->ISA(); tcls; tcls = tcls->getSuperclass()) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls->getSuperclass()) {
        if (tcls == cls) return YES;
    }
    return NO;
} 

##drawRect
1. view初始化时候会调用, 但是如果没有设置frame, 此时是不会自动调用drawrect的;
2. 调用sizeThatFits后会调用.
3. 设置contentMode = UIViewContentModeRedraw时候, 设置或改变view的frame时候会调用.
4. 调用 setNeedsDisplay 或 setNeedsDisplayInRect 会调用drawRect, 但此时的rect不能是0;
如果在drawRect中重复创建对象, 并且没有释放, 就会导致视图错误, 内存暴增.
 

##layoutSubView
1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。
2.addSubview会触发layoutSubviews
3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化
4.滚动一个UIScrollView会触发layoutSubviews
5.旋转Screen会触发父UIView上的layoutSubviews事件
6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件

二进制化优化编译速度
1. 创建pod私有库
2. 在私有库Demo中创建静态库target
3. 创建打包脚本用来伸长静态库
4. 设置.gitignore忽略输出的二进制包
5. 配置podspec根据tag版本判断或根据环境变量判断
Pod::Spec.new do |s|
  s.name             = 'ABC'
  s.version          = '0.1.0.Binary'
  s.summary          = 'A short description of ABC.'

  s.description      = <<-DESC
TODO: Add long description of the pod here.
                       DESC
  
  s.homepage         = 'https://github.com/609223770@qq.com/ABC'
  # s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'
  s.license          = { :type => 'MIT', :file => 'LICENSE' }
  s.author           = { '609223770@qq.com' => '609223770@qq.com' }
  s.source           = { :git => 'https://github.com/609223770@qq.com/ABC.git', :tag => s.version.to_s }
  # s.social_media_url = 'https://twitter.com/<TWITTER_USERNAME>'

  s.ios.deployment_target = '8.0'
  
  if s.version.to_s.include?'Binary'    
    puts '-------------------------------------------------------------------'
    puts 'Notice:ABC is binary now'
    puts '-------------------------------------------------------------------'
    s.prepare_command = '/bin/bash build_lib.sh'
    s.source_files = 'Pod/Products/include/**'
    s.ios.vendored_libraries = 'Pod/Products/lib/*.a'
    s.public_header_files = 'Pod/Products/include/*.h'    
  else
    puts '-------------------------------------------------------------------'
    puts 'Notice:ABC is source code now'
    puts '-------------------------------------------------------------------'
    s.source_files = 'ABC/Classes/**/*'
  end
end
6. 验证并上传源码及二进制的podspec
7. 在实际项目中切换时需要执行pod update或删除Podfile.lock中相关库信息

 ##iOS沙盒目录的作用
 Documents: 程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录。
 Library/Preferences : 存储用户偏好设置,NSUserDefaults就存放在这个目录下.
 Library/Caches : 存储应用程序专用的支持文件,保存应用程序重启后需要的信息, 通常应用使用的缓存存放在这个文件夹中.
 可创建子文件夹，用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份。
 temp: 存放临时文件, 保存程序重新启动🙅🏻‍♀️需要的信息. 不会被iTunes备份, 
##iOS中的崩溃
    KVC, KVO, 数组越界 方法找不到 野指针 
    内存占用过高, 后台任务超时, 主线程死锁
##项目中横屏弹幕的实现方法
##YYLabel实现 为什么换成YYLabel
##纹理坐标系和顶点坐标系
##mach-O文件格式
##xcode性能分析工具
##崩溃分析
##符号表的解析
##如何自己定位崩溃
##CoreText
1. coretext的坐标系中, 左下角是(0,0)
2.CTFrame是一块画布, CTLine表示每一行, CTRun表示每一行中同一样式的块.
## 汇编的常用寄存器
x0 - x7:用来存放函数参数
x0: 用来存放函数的返回值
sp: 栈指针, 通过sp修改栈空间的大小
fp(x29) : 栈底指针
lr(x30) : 保存函数的返回地址.
pc : 程序将要执行的指令的地址
cpsr: 状态寄存器, 通常条件分支时候会用到.
##dyld加载原理
##bind 和 rebase
mach-O中的懒加载函数地址是在函数执行到那个函数的时候, 替换的函数的真实的实现地址.
rebase: 正常情况下, 由于空间随机化的存在, 在dyld加载可执行文件到内存之后, 会对所有指向进程内的符号地址进行调整, 修改的过程称为rebase.
bind : 将每个函数绑定到对应的函数地址上, 叫做bind;

